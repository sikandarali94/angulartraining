<!--
$event is a used variable name that we can use in the template when using event
binding. $event is the data emitted with that event. So input and click are
default events provided by the DOM and they ship some data when they are fired.
All that data is packed into the $event variable.
Our first input element will not be pre-populated with the serverName value
pre-defined in the component model when we run the app because the first
input element is not using two-way binding.
-->
<label>Server Name</label>
<!--<input type="text" class="form-control" (input) = "onUpdateServerName($event)"/>-->
<!--
With two-way binding we use both property binding and event binding. That is why we
use the square brackets and within them parenthesis to indicate we are using
two-way data binding. ngModel that we used within the two-way binding down below
is a directive. This will trigger on the input event and update the value of the serverName
in our component model automatically. On the other hand, since it is two-way
binding it will also update the value of the input element if we change serverName somewhere
else.
-->
<input type="text"
       class="form-control"
       [(ngModel)]="serverName"/>
<!--<p>{{ serverName }}</p>-->
<!--
Square brackets ([]) indicate to Angular that we are using property binding.
It tells Angular that we want to dynamically bind a property.Each HTML
element we use is parsed by the browser and kind of translated into a element
on the DOM. Therefore we have an element in this DOM and this element has a
couple of properties. A lot of these can't even be set through attributes on the
HTML element. One of those properties is the disabled property and we can set it
through the disabled attribute but here we are not using the 'disabled attribute
anymore. With the square brackets we are directly binding to this native disabled
property this HTML element has. Thus, there are a lot of native properties of
elements that we can property bind to. Some of these native properties are resolved
through a boolean but some are resolved through other values. The disabled native
property is resolved to a true boolean so that is why we equal it to !allowNewServer,
because if allowNewServer is false within the component model then we want the button
to be disabled.

Parenthesis indicates to Angular that we are using event binding. Within the
parenthesis we name the event. By naming the event (click) we are using the onclick
HTML DOM event. This naming convention is for all events. Therefore, in Angular we
write the HTML DOM event name within the parenthesis but with the 'on' prefix removed.
Here we called the onCreateServer method that we defined in the component model.
However, we can also write the code inside the quotation marks that we want to execute.
However, it is a better convention to define the code in a method within the model
component and call it using event binding. If it is a simple code of one line then
it is acceptable as per convention to write it in the quotation marks rather than
define a method in component model.
-->
<button class="btn btn-primary" [disabled]="!allowNewServer" (click)="onCreateServer()">Add Server</button>
<!--
innerText is another native property of an element we can use (in this case the p
element). This native property is resolved through a string which it then places
inside the p tags. This is an alternative to using string interpolation like this:
<p>{{ allowNewServer }}</p>.

We should use string interpolation if we want to output something to the template
or print something. If we want to change some property of an element we use property
binding. An important thing to note is not to mix property binding with string
interpolation. For example this will will break our app:
[disabled] = {{ !allowNewServer }}
-->
<!--<p [innerText] = "allowNewServer"></p>-->
<!--<p>{{ serverCreationStatus }}</p>-->
<!--
The star(*) is required as a prefix to ngIf because ngIf is a structural directive.
A structural directive changes the structure of our DOM. With ngIf it either adds the
p element or it doesn't add the p element. Within the quotation marks next to ngIf
the expression must either resolve to a true or to a false. Or we could call a method
inside that either resolves to true or false. When serverCreated is false the p
element is not hidden in the DOM, it just isn't there.
If we want to use an else conditional statement we put a semicolon after the
conditional expression and type else with the local reference without the hash(#).
This tells Angular that if the conditional expression is not true then load up
the DOM template that we defined in the ng-template directive and marked with
the local reference that we placed next to the else statement.
-->
<p *ngIf="serverCreated; else noServer">Server was created, server name is {{ serverName }}</p>
<!--
The # indicates that it this is a local reference. ng-template is a component with
a directive shipped with Angular which we can use to mark places in the DOM.
-->
<ng-template #noServer>
    <p>
    No server was created!
    </p>
</ng-template>
<!--
Components are reusable in Angular. So we can use this
-->
<app-server></app-server>
<app-server></app-server>